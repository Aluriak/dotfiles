#!/bin/bash
# Try to find local python package, its version, to update it and finally commit it.
# Suffers many limits:
#  - Version has to be in the setup.cfg or __init__.py
#  - version must be in the form \d.\d.\d
#  - will aggressively replace in the whole target file any occurence of old version by the new one. Watch out when upgrading from version 127.0.0.
#  - will commit changes of the entires __init__.py or setup.cfg file
# But it will hopefully:
#  - not try to commit in the absence of git repository
#  - propose to amend previous commit only if it was not pushed (using git status -b and looking for [ahead X] substring in output)
#  - use the package attr shown in setup.cfg as `version: attr: llib.theversion` to obtain current version

uptype=$1

while
    if [[ ! $uptype ]]
    then
        echo -n "Which update ? (x.y.z)"
        read uptype
    fi
    if [[ $uptype == x || $uptype == m || $uptype == a || $uptype == j ]]
    then
        uptype=major
    elif [[ $uptype == y || $uptype == i || $uptype == n ]]
    then
        uptype=minor
    elif [[ $uptype == z || $uptype == b ]]
    then
        uptype=bugfix
    else
        uptype=
    fi
    [[ ! $uptype ]]
do true ; done


if [[ -e setup.cfg ]]
then
    seen_version=$(cat setup.cfg | grep -E '^version')
    echo $seen_version
    setupcfg_version=$(echo $seen_version | sed -E 's/^version\s?=\s?([0-9\.]+).*$/\1/')
    module_version=$(echo $seen_version | sed -E 's/^version\s?=\s?attr:\s?(.*)$/\1/')
    echo $seen_version
    if [[ $module_version ]]
    then
        echo "looking into $module_version…"
        module=$(echo $module_version | cut -d . -f 1)
        attrs=$(echo $module_version | cut -d . -f 2-)
        version=$(python -c "import $module as m; print(m.$attrs)")
        writingbackvia=module_version
    elif [[ $setupcfg_version ]]
    then
        version=setupcfg_version
        writingbackvia=setupcfg_version
    fi
elif [[ -e __init__.py ]]
then
    init_version=$(cat __init__.py | grep -E '^_*version_*\s*=\s*.([0-9\.]+).$' | sed -E 's/^_*version_*\s*=\s*.([0-9\.]+).$/\1/')
    if [[ $init_version ]]
    then
        version=$init_version
        writingbackvia=init_version
    fi
fi
echo "version is $version"
v_major=$(echo $version | cut -d . -f1)
v_minor=$(echo $version | cut -d . -f2)
v_bugfx=$(echo $version | cut -d . -f3)
if [[ $uptype == major ]]
then
    v_major=$(expr $v_major + 1)
    v_minor=0
    v_bugfx=0
elif [[ $uptype == minor ]]
then
    v_minor=$(expr $v_minor + 1)
    v_bugfx=0
elif [[ $uptype == bugfix ]]
then
    v_bugfx=$(expr $v_bugfx + 1)
fi
newversion="$v_major.$v_minor.$v_bugfx"
echo "with $uptype update: $newversion"

if [[ $writingbackvia == setupcfg_version ]]
then
    # echo "Modifying setup.cfg"
    sed -i "s/$version/$newversion/" "setup.cfg"
    target=setup.cfg
elif [[ $writingbackvia == module_version ]]
then
    # echo "looking in module $module for file __init__.py and attribute $attrs…"
    sed -i "s/$version/$newversion/" "$module/__init__.py"
    target=$module/__init__.py
elif [[ $writingbackvia == init_version ]]
then
    sed -i "s/$version/$newversion/" "__init__.py"
    target=__init__.py
fi

gitout=$(git status --porcelain -b)
# output if not git repo: (none)
# output if equal: prod...origin/prod
# output if ahead: prod...origin/prod [ahead 1]
if [[ ! $gitout ]]
then
    echo "Not in a git repository. The end."
    exit
fi

echo "previous commit is:"
git log -1
echo "Prepare commit…"
git add "$target"
git diff --staged

isahead=$(echo $gitout | grep -E '\[ahead [0-9]+\]')
if [[ $isahead ]]
then
    echo -n "Commit ?[y/a/N]"
else
    echo -n "Commit ?[y/N]"
fi
read ok
if [[ $ok == y || $ok == Y || $ok == o || $ok == yes ]]
then
    git commit -m "$newversion"
elif [[ $isahead && ( $ok == a || $ok == A ) ]]
then
    git commit --amend -m "$newversion"
fi
